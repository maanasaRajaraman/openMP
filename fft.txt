#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <omp.h>

#define PI 3.14159265358979323846
#define N 1024  // FFT size

typedef struct {
    double real;
    double imag;
} Complex;

// Function to perform complex multiplication
Complex complex_mul(Complex a, Complex b) {
    Complex result;
    result.real = a.real * b.real - a.imag * b.imag;
    result.imag = a.real * b.imag + a.imag * b.real;
    return result;
}

// Sequential FFT
void fft_sequential(Complex *X) {
    for (int s = 1; s <= log2(N); s++) {
        int m = 1 << s;
        double angle = -2.0 * PI / m;
        Complex wm = {cos(angle), sin(angle)};

        for (int k = 0; k < N; k += m) {
            Complex w = {1.0, 0.0};
            for (int j = 0; j < m / 2; j++) {
                Complex t = complex_mul(w, X[k + j + m / 2]);
                Complex u = X[k + j];
                X[k + j] = (Complex){u.real + t.real, u.imag + t.imag};
                X[k + j + m / 2] = (Complex){u.real - t.real, u.imag - t.imag};
                w = complex_mul(w, wm);
            }
        }
    }
}

// Parallel FFT using OpenMP
void fft_parallel(Complex *X) {
    for (int s = 1; s <= log2(N); s++) {
        int m = 1 << s;
        double angle = -2.0 * PI / m;
        Complex wm = {cos(angle), sin(angle)};

        #pragma omp parallel for
        for (int k = 0; k < N; k += m) {
            Complex w = {1.0, 0.0};
            for (int j = 0; j < m / 2; j++) {
                Complex t = complex_mul(w, X[k + j + m / 2]);
                Complex u = X[k + j];
                X[k + j] = (Complex){u.real + t.real, u.imag + t.imag};
                X[k + j + m / 2] = (Complex){u.real - t.real, u.imag - t.imag};
                w = complex_mul(w, wm);
            }
        }
    }
}

int main() {
    Complex data_seq[N], data_par[N];

    // Initialize input data
    for (int i = 0; i < N; i++) {
        data_seq[i].real = data_par[i].real = sin(2 * PI * i / N);
        data_seq[i].imag = data_par[i].imag = 0.0;
    }

    // Sequential FFT
    double seq_start = omp_get_wtime();
    fft_sequential(data_seq);
    double seq_end = omp_get_wtime();

    // Parallel FFT
    double par_start = omp_get_wtime();
    fft_parallel(data_par);
    double par_end = omp_get_wtime();

    // Verify correctness
    int correct = 1;
    for (int i = 0; i < N; i++) {
        if (fabs(data_seq[i].real - data_par[i].real) > 1e-6 ||
            fabs(data_seq[i].imag - data_par[i].imag) > 1e-6) {
            correct = 0;
            break;
        }
    }

    // Print results
    printf("Sequential FFT Time: %.6f seconds\n", seq_end - seq_start);
    printf("Parallel FFT Time:   %.6f seconds\n", par_end - par_start);
    printf("Correctness Check: %s\n", correct ? "PASS" : "FAIL");

    return 0;
}
